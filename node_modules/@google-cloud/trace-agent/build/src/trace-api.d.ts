/// <reference types="node" />
import { EventEmitter } from 'events';
import { OpenCensusPropagation, TracePolicy } from './config';
import { SpanType } from './constants';
import { Logger } from './logger';
import { Func, Propagation, RootSpan, RootSpanOptions, Span, SpanOptions, Tracer } from './plugin-types';
import * as util from './util';
/**
 * An interface describing configuration fields read by the StackdriverTracer
 * object. This includes fields read by the trace policy.
 */
export interface StackdriverTracerConfig {
    enhancedDatabaseReporting: boolean;
    rootSpanNameOverride: (path: string) => string;
    spansPerTraceSoftLimit: number;
    spansPerTraceHardLimit: number;
}
/**
 * A collection of externally-instantiated objects used by StackdriverTracer.
 */
export interface StackdriverTracerComponents {
    logger: Logger;
    tracePolicy: TracePolicy;
    propagation: OpenCensusPropagation;
}
/**
 * StackdriverTracer exposes a number of methods to create trace spans and
 * propagate trace context across asynchronous boundaries.
 */
export declare class StackdriverTracer implements Tracer {
    readonly constants: {
        TRACE_CONTEXT_GRPC_METADATA_NAME: string;
        TRACE_CONTEXT_HEADER_NAME: string;
        TRACE_AGENT_REQUEST_HEADER: string;
        TRACE_OPTIONS_TRACE_ENABLED: number;
        TRACE_SERVICE_SPAN_NAME_LIMIT: number;
        TRACE_SERVICE_LABEL_KEY_LIMIT: number;
        TRACE_SERVICE_LABEL_VALUE_LIMIT: number;
    };
    readonly labels: {
        HTTP_RESPONSE_CODE_LABEL_KEY: string;
        HTTP_URL_LABEL_KEY: string;
        HTTP_METHOD_LABEL_KEY: string;
        HTTP_RESPONSE_SIZE_LABEL_KEY: string;
        STACK_TRACE_DETAILS_KEY: string;
        ERROR_DETAILS_NAME: string;
        ERROR_DETAILS_MESSAGE: string;
        GAE_VERSION: string;
        GAE_MODULE_NAME: string;
        GAE_MODULE_VERSION: string;
        GCE_INSTANCE_ID: string;
        GCE_HOSTNAME: string;
        HTTP_SOURCE_IP: string;
        AGENT_DATA: string;
    };
    readonly spanTypes: typeof SpanType;
    readonly traceContextUtils: {
        encodeAsByteArray: typeof util.serializeTraceContext;
        decodeFromByteArray: typeof util.deserializeTraceContext;
    };
    readonly propagation: Propagation;
    private enabled;
    private pluginName;
    private pluginNameToLog;
    private logger;
    private config;
    private policy;
    private headerPropagation;
    /**
     * Constructs a new StackdriverTracer instance.
     * @param name A string identifying this StackdriverTracer instance in logs.
     */
    constructor(name: string);
    /**
     * Enables this instance. This function is only for internal use and
     * unit tests. A separate TraceWriter instance should be initialized
     * beforehand.
     * @param config An object specifying how this instance should
     * be configured.
     * @param components An collection of externally-instantiated objects used
     * by this instance.
     * @private
     */
    enable(config: StackdriverTracerConfig, components: StackdriverTracerComponents): void;
    /**
     * Disable this instance. This function is only for internal use and
     * unit tests.
     * @private
     */
    disable(): void;
    /**
     * Returns whether the StackdriverTracer instance is active. This function is
     * only for internal use and unit tests; under normal circumstances it will
     * always return true.
     * @private
     */
    isActive(): boolean;
    enhancedDatabaseReportingEnabled(): boolean;
    getConfig(): StackdriverTracerConfig;
    runInRootSpan<T>(options: RootSpanOptions, fn: (span: RootSpan) => T): T;
    getCurrentRootSpan(): RootSpan;
    getCurrentContextId(): string | null;
    getProjectId(): Promise<string>;
    getWriterProjectId(): string | null;
    createChildSpan(options?: SpanOptions): Span;
    isRealSpan(span: Span): boolean;
    getResponseTraceContext(incomingTraceContext: util.TraceContext | null, isTraced: boolean): {
        traceId: string;
        spanId: string;
        options: number;
    } | null;
    wrap<T>(fn: Func<T>): Func<T>;
    wrapEmitter(emitter: EventEmitter): void;
}
