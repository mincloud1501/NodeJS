"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
// Copyright 2015 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * An enumeration of the different possible types of behavior when dealing with
 * incoming trace context. Requests are still subject to local tracing policy.
 */
var TraceContextHeaderBehavior;
(function (TraceContextHeaderBehavior) {
    /**
     * Respect the trace context header if it exists; otherwise, trace the
     * request as a new trace.
     */
    TraceContextHeaderBehavior["DEFAULT"] = "default";
    /**
     * Respect the trace context header if it exists; otherwise, treat the
     * request as unsampled and don't trace it.
     */
    TraceContextHeaderBehavior["REQUIRE"] = "require";
    /**
     * Trace every request as a new trace, even if trace context exists.
     */
    TraceContextHeaderBehavior["IGNORE"] = "ignore";
})(TraceContextHeaderBehavior = exports.TraceContextHeaderBehavior || (exports.TraceContextHeaderBehavior = {}));
class Sampler {
    constructor(samplesPerSecond) {
        if (samplesPerSecond > 1000) {
            samplesPerSecond = 1000;
        }
        this.traceWindow = 1000 / samplesPerSecond;
        this.nextTraceStart = Date.now();
    }
    shouldTrace(dateMillis) {
        if (dateMillis < this.nextTraceStart) {
            return false;
        }
        this.nextTraceStart = dateMillis + this.traceWindow;
        return true;
    }
}
class URLFilter {
    constructor(filterUrls) {
        this.filterUrls = filterUrls;
    }
    shouldTrace(url) {
        return !this.filterUrls.some(candidate => {
            return ((typeof candidate === 'string' && candidate === url) ||
                !!url.match(candidate));
        });
    }
}
class MethodsFilter {
    constructor(filterMethods) {
        this.filterMethods = filterMethods;
    }
    shouldTrace(method) {
        return !this.filterMethods.some(candidate => {
            return candidate.toLowerCase() === method.toLowerCase();
        });
    }
}
class ContextHeaderFilter {
    constructor(contextHeaderBehavior) {
        this.contextHeaderBehavior = contextHeaderBehavior;
    }
    shouldTrace(header) {
        switch (this.contextHeaderBehavior) {
            case TraceContextHeaderBehavior.IGNORE: {
                return true;
            }
            case TraceContextHeaderBehavior.REQUIRE: {
                // There must be an incoming header, and its LSB must be 1.
                return !!(header && header.options & constants_1.Constants.TRACE_OPTIONS_TRACE_ENABLED);
            }
            default: {
                // TraceContextHeaderBehavior.DEFAULT
                // If there is a header, its LSB must be 1. Otherwise, we assume that
                // it would be 1.
                return !!(!header || header.options & constants_1.Constants.TRACE_OPTIONS_TRACE_ENABLED);
            }
        }
    }
}
/**
 * A class that makes decisions about whether a trace should be created.
 */
class BuiltinTracePolicy {
    /**
     * Constructs a new TracePolicy instance.
     * @param config Configuration for the TracePolicy instance.
     */
    constructor(config) {
        if (config.samplingRate === 0) {
            this.sampler = { shouldTrace: () => true };
        }
        else if (config.samplingRate < 0) {
            this.sampler = { shouldTrace: () => false };
        }
        else {
            this.sampler = new Sampler(config.samplingRate);
        }
        if (config.ignoreUrls.length === 0) {
            this.urlFilter = { shouldTrace: () => true };
        }
        else {
            this.urlFilter = new URLFilter(config.ignoreUrls);
        }
        if (config.ignoreMethods.length === 0) {
            this.methodsFilter = { shouldTrace: () => true };
        }
        else {
            this.methodsFilter = new MethodsFilter(config.ignoreMethods);
        }
        if (config.contextHeaderBehavior === TraceContextHeaderBehavior.IGNORE) {
            this.contextHeaderFilter = { shouldTrace: () => true };
        }
        else {
            this.contextHeaderFilter = new ContextHeaderFilter(config.contextHeaderBehavior);
        }
    }
    /**
     * Given a timestamp and URL, decides if a trace should be created.
     * @param options Fields that help determine whether a trace should be
     *                created.
     */
    shouldTrace(options) {
        return (this.urlFilter.shouldTrace(options.url) &&
            this.methodsFilter.shouldTrace(options.method) &&
            this.contextHeaderFilter.shouldTrace(options.traceContext) &&
            this.sampler.shouldTrace(options.timestamp));
    }
}
exports.BuiltinTracePolicy = BuiltinTracePolicy;
function alwaysTrace() {
    return new BuiltinTracePolicy({
        samplingRate: 0,
        ignoreUrls: [],
        ignoreMethods: [],
        contextHeaderBehavior: TraceContextHeaderBehavior.DEFAULT,
    });
}
exports.alwaysTrace = alwaysTrace;
function neverTrace() {
    return new BuiltinTracePolicy({
        samplingRate: -1,
        ignoreUrls: [],
        ignoreMethods: [],
        contextHeaderBehavior: TraceContextHeaderBehavior.DEFAULT,
    });
}
exports.neverTrace = neverTrace;
//# sourceMappingURL=tracing-policy.js.map